// Auto-generated by es-fluent CLI for checking FTL files
// extern crate is required to ensure the crate is linked even if nothing is explicitly used.
// This allows inventory to collect the registered type infos.
extern crate {{ crate_ident }};

use std::collections::{HashMap, HashSet};
use std::path::Path;

fn main() {
    // Read config from parent crate's i18n.toml
    let i18n_toml_path = std::path::Path::new("{{ i18n_toml_path }}");
    let config = es_fluent::es_fluent_toml::I18nConfig::read_from_path(i18n_toml_path)
        .expect("Failed to read i18n.toml");

    let i18n_dir = i18n_toml_path.parent().expect("Failed to get i18n directory");
    let assets_dir = i18n_dir.join(&config.assets_dir);

    let crate_name = "{{ crate_name }}";
    let crate_ident = crate_name.replace('-', "_");

    // Collect all registered type infos for this crate
    let type_infos: Vec<_> = es_fluent::__core::registry::get_all_ftl_type_infos()
        .into_iter()
        .filter(|info| {
            info.module_path == crate_ident
                || info.module_path.starts_with(&format!("{}::", crate_ident))
        })
        .collect();

    // Build a map of expected keys and their required variables
    let mut expected_keys: HashMap<String, HashSet<String>> = HashMap::new();
    for info in &type_infos {
        for variant in &info.variants {
            let key = variant.ftl_key.0.clone();
            let vars: HashSet<String> = variant.args.iter().cloned().collect();
            expected_keys.insert(key, vars);
        }
    }

    // Get locales to check
    let check_all = {{ check_all }};
    let locales: Vec<String> = if check_all {
        get_all_locales(&assets_dir)
    } else {
        vec![config.fallback_language.clone()]
    };

    let mut errors: Vec<String> = Vec::new();
    let mut warnings: Vec<String> = Vec::new();

    for locale in &locales {
        let locale_dir = assets_dir.join(locale);
        let ftl_file = locale_dir.join(format!("{}.ftl", crate_name));

        if !ftl_file.exists() {
            // Report all keys as missing for this locale
            for key in expected_keys.keys() {
                errors.push(format!(
                    "MISSING_KEY|{}|{}|{}",
                    locale, key, ftl_file.display()
                ));
            }
            continue;
        }

        let content = match std::fs::read_to_string(&ftl_file) {
            Ok(c) => c,
            Err(e) => {
                errors.push(format!(
                    "READ_ERROR|{}|{}|{}",
                    locale, ftl_file.display(), e
                ));
                continue;
            }
        };

        // Parse the FTL file
        let resource = match fluent_syntax::parser::parse(content.clone()) {
            Ok(res) => res,
            Err((res, parse_errors)) => {
                for err in &parse_errors {
                    errors.push(format!(
                        "SYNTAX_ERROR|{}|{}|{:?}",
                        locale, ftl_file.display(), err.kind
                    ));
                }
                res
            }
        };

        // Build map of actual keys and their variables in the FTL file
        let mut actual_keys: HashMap<String, HashSet<String>> = HashMap::new();
        for entry in &resource.body {
            if let fluent_syntax::ast::Entry::Message(msg) = entry {
                let key = msg.id.name.clone();
                let vars = extract_variables_from_message(msg);
                actual_keys.insert(key, vars);
            }
        }

        // Check for missing keys
        for (key, expected_vars) in &expected_keys {
            if let Some(actual_vars) = actual_keys.get(key) {
                // Key exists, check for missing variables
                for var in expected_vars {
                    if !actual_vars.contains(var) {
                        warnings.push(format!(
                            "MISSING_VAR|{}|{}|{}|{}",
                            locale, key, var, ftl_file.display()
                        ));
                    }
                }
            } else {
                // Key is missing
                errors.push(format!(
                    "MISSING_KEY|{}|{}|{}",
                    locale, key, ftl_file.display()
                ));
            }
        }
    }

    // Output results in a parseable format
    println!("---ES_FLUENT_CHECK_RESULTS---");
    println!("ERRORS:{}", errors.len());
    println!("WARNINGS:{}", warnings.len());
    for error in &errors {
        println!("E:{}", error);
    }
    for warning in &warnings {
        println!("W:{}", warning);
    }
    println!("---ES_FLUENT_CHECK_END---");

    // Exit with error code if there are errors
    if !errors.is_empty() {
        std::process::exit(1);
    }
}

fn get_all_locales(assets_dir: &Path) -> Vec<String> {
    let mut locales = Vec::new();
    if let Ok(entries) = std::fs::read_dir(assets_dir) {
        for entry in entries.flatten() {
            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
                if let Some(name) = entry.file_name().to_str() {
                    locales.push(name.to_string());
                }
            }
        }
    }
    locales.sort();
    locales
}

fn extract_variables_from_message(msg: &fluent_syntax::ast::Message<String>) -> HashSet<String> {
    let mut variables = HashSet::new();
    if let Some(ref value) = msg.value {
        extract_variables_from_pattern(value, &mut variables);
    }
    for attr in &msg.attributes {
        extract_variables_from_pattern(&attr.value, &mut variables);
    }
    variables
}

fn extract_variables_from_pattern(
    pattern: &fluent_syntax::ast::Pattern<String>,
    variables: &mut HashSet<String>,
) {
    for element in &pattern.elements {
        if let fluent_syntax::ast::PatternElement::Placeable { expression } = element {
            extract_variables_from_expression(expression, variables);
        }
    }
}

fn extract_variables_from_expression(
    expression: &fluent_syntax::ast::Expression<String>,
    variables: &mut HashSet<String>,
) {
    match expression {
        fluent_syntax::ast::Expression::Inline(inline) => {
            extract_variables_from_inline(inline, variables);
        }
        fluent_syntax::ast::Expression::Select { selector, variants } => {
            extract_variables_from_inline(selector, variables);
            for variant in variants {
                extract_variables_from_pattern(&variant.value, variables);
            }
        }
    }
}

fn extract_variables_from_inline(
    inline: &fluent_syntax::ast::InlineExpression<String>,
    variables: &mut HashSet<String>,
) {
    match inline {
        fluent_syntax::ast::InlineExpression::VariableReference { id } => {
            variables.insert(id.name.clone());
        }
        fluent_syntax::ast::InlineExpression::FunctionReference { arguments, .. } => {
            for arg in &arguments.positional {
                extract_variables_from_inline(arg, variables);
            }
            for arg in &arguments.named {
                extract_variables_from_inline(&arg.value, variables);
            }
        }
        fluent_syntax::ast::InlineExpression::Placeable { expression } => {
            extract_variables_from_expression(expression, variables);
        }
        _ => {}
    }
}
