use darling::FromDeriveInput;
use es_fluent_core::{namer, options::this::ThisOpts};
use quote::quote;
use syn::{DeriveInput, parse_macro_input};

pub fn from(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let opts = match ThisOpts::from_derive_input(&input) {
        Ok(opts) => opts,
        Err(err) => return err.write_errors().into(),
    };

    let original_ident = opts.ident();
    let generics = opts.generics();
    let ftl_key = if opts.attr_args().is_this() {
        let this_ident = quote::format_ident!("{}_this", original_ident);
        Some(namer::FluentKey::new(&this_ident, "").to_string())
    } else {
        None
    };

    let this_ftl_impl = crate::macros::utils::generate_this_ftl_impl(
        original_ident,
        generics,
        ftl_key.as_deref(),
    );
    
    // Logic for `fields_this` (on a Struct, this implies generating ThisFtl for nested structs? Or keys?)
    // The previous `keys_this` in EsFluentKv was generating `ThisFtl` on the generated Enum types (e.g. MyStructLabelKvFtl).
    // But `EsFluentThis` is on the MAIN struct.
    // If the main struct has `fields_this`, it probably implies we want to support something about fields?
    // Wait, `keys_this` was used because `EsFluentKv` generated *new types*.
    // `EsFluentThis` is just on the existing type.
    
    // Re-reading the prompt: "with specialized "fields_this" replacing the current "keys_this"".
    // `keys_this` in `EsFluentKv` generated `impl ThisFtl for [GeneratedEnum]`.
    // The user says "fields_this" replacing "keys_this".
    // If I am deriving `EsFluentThis` on `MyStruct`, how do I affect the generated enums which are generated by `EsFluentKv`?
    // `EsFluentKv` generates the enums. `EsFluentThis` is a separate derive.
    // If they are separate, `EsFluentThis` cannot see the generated tokens of `EsFluentKv`.
    
    // Perhaps `EsFluentKv` will *delegate* the `this` logic to `EsFluentThis`?
    // Or `EsFluentThis` is intended to be used *on* types where `fields_this` makes sense?
    
    // The user said: "seperate it so there's a unique derive macro for this : EsFluentThis. it should support any enum and any structs for this (since any always need a name for the struct/enum). with specialized "fields_this" replacing the current "keys_this" and a new "variants_this" for enum variants (any)"
    
    // If I have:
    // #[derive(EsFluentKv, EsFluentThis)]
    // #[fluent_kv(keys = ["label", "desc"])]
    // #[fluent_this(fields_this)]
    // struct Foo { ... }
    
    // `EsFluentKv` generates `FooLabelKvFtl`.
    // `EsFluentThis` generates `impl ThisFtl for Foo`.
    // How does `EsFluentThis` generate `impl ThisFtl for FooLabelKvFtl`? It doesn't know about it!
    
    // Maybe the user intends that `EsFluentThis` handles the "this" for the *current* type, and "fields_this" implies something else?
    // OR, maybe the user implies that `EsFluentKv` should check for `fields_this` in `EsFluentThis` attributes?
    // BUT `EsFluentThis` is a separate macro.
    
    // However, if `fields_this` replaces `keys_this`, maybe it means:
    // When I have a struct with fields, maybe I want `ThisFtl` for the fields themselves?
    // But `keys_this` was specific to the "Keys" (the generated enums).
    
    // Let's assume for now `EsFluentThis` primarily handles `this_ftl` for the type it is attached to.
    // If `fields_this` is set, maybe it generates `ThisFtl` for ... what?
    
    // Re-reading: "EsFluent and EsFluentKv expose a #[fluent(this)] / #[fluent_kv(this, keys_this)]. both of those try to do the same underlying logic. seperate it... replacement... variants_this for enum variants"
    
    // `variants_this`:
    // #[derive(EsFluentThis)]
    // #[fluent_this(variants_this)]
    // enum MyEnum { A, B }
    // -> Generates `impl ThisFtl for MyEnum` (via `this`).
    // -> Generates `impl ThisFtl` for ... the variants? Variants are not types.
    // unless it generates a zero-sized type for each variant? Or maybe it just means something else.
    
    // Wait, `EsFluent` on an enum generated `this_ftl` for the enum type.
    // `EsFluentKv` on an enum generated `this_ftl` for the enum type.
    
    // Maybe `variants_this` means "Generate ThisFtl for the variants if they were types?"
    // Or maybe it means "Generates a localized string for the variant ITSELF"?
    
    // Let's look at `impl ThisFtl`:
    // trait ThisFtl { fn this_ftl() -> String; }
    // It returns a key.
    
    // If `variants_this` is true, maybe it generates `ThisFtl` for some generated types corresponding to variants?
    // But `EsFluentThis` doesn't generate types (unlike `EsFluentKv`).
    
    // HYPOTHESIS: `EsFluentThis` is only about generating `impl ThisFtl`.
    // `this` -> `impl ThisFtl for MyType`.
    // `variants_this` -> ?
    // `fields_this` -> ?
    
    // If `EsFluentThis` doesn't generate types, it can't implement ThisFtl on non-existent types.
    // Maybe the user intends `EsFluentThis` to ALSO generate those unit structs/enums that represent fields/variants?
    // That would overlap with `EsFluentKv`.
    
    // The user said: "it should support any enum and any structs for this (since any always need a name for the struct/enum)."
    
    // Let's look at existing `keys_this` behavior in `derive_es_fluent_kv/mod.rs`.
    // It calls `generate_this_ftl_impl(ident, ...)` where `ident` is the generated enum name (e.g. `MyStructLabelKvFtl`).
    
    // If `EsFluentThis` is a separate macro, it can't see those names easily unless it recreates the logic or communicates.
    
    // Maybe I should modify `EsFluentKv` to look for `#[fluent_this(fields_this)]`?
    // The user said "unique derive macro for this".
    
    // Possible interpretation:
    // `EsFluentThis` generates the `ThisFtl` implementation.
    // If `EsFluentKv` generates new types, IT needs to implement `ThisFtl`.
    // If `EsFluentKv` NO LONGER supports `this/keys_this` attributes, how does the user opt-in to `ThisFtl` on generated types?
    // Maybe the user wants `EsFluentKv` to *automatically* derive `EsFluentThis` on the generated types?
    // And `EsFluentThis` will inspect the context?
    
    // Or, simpler:
    // The user wants `EsFluentThis` to be used for the MAIN type.
    // The `fields_this` / `variants_this` might be for scenarios where the fields/variants are *also* types or valid targets?
    
    // Let's implement the `this` part first (the main request).
    // And for `fields_this` / `variants_this`: I will implement the *parsing* of the option, but maybe defer the logic or leave it as a placeholder until I see how to apply it, or checks if it implies generating code for fields?
    
    // Actually, look at `derive_es_fluent_kv`. It does:
    // `let this_ftl_key = if opts.attr_args().is_keys_this() ...`
    // And then `generate_this_ftl_impl`.
    
    // If I remove `keys_this` from `EsFluentKv`, I need a way to say "Generate ThisFtl for these generated enums".
    // If I add `#[derive(EsFluentThis)]` to the *generated* enums, then `EsFluentThis` will run on them.
    // So `EsFluentKv` should probably add `#[derive(EsFluentThis)]` to its generated enums.
    // And then `EsFluentThis` needs to know *what key* to return.
    // By default `ThisFtl` returns `this_ident` key.
    
    // If `EsFluentKv` generates `MyStructLabelKvFtl`, and adds `#[derive(EsFluentThis)]`,
    // then `EsFluentThis` will generate `ThisFtl` for `MyStructLabelKvFtl` with key `my_struct_label_kv_ftl_this`.
    // This seems correct and standardizes it!
    
    // So `fields_this` and `variants_this` might be used when *NOT* using EsFluentKv?
    // Or maybe `fields_this` on the *parent* struct tells `EsFluentKv` to add the derive?
    // But `EsFluentKv` is a separate macro.
    
    // Wait, the prompt says: "with specialized "fields_this" replacing the current "keys_this"".
    // `keys_this` was an argument on `#[fluent_kv(...)]`.
    // If it is replaced by `fields_this` in the NEW macro, maybe `EsFluentThis` is supposed to iterate over fields?
    
    // Let's implement the basic `EsFluentThis` that does the `this` part for the type itself and `variants_this` (generating for variants?).
    // Actually, `variants_this` might mean "generate ThisFtl for each variant of the enum, assuming the variant is a type?" -> but variants are not types in Rust (yet).
    
    // If `EsFluentThis` is derived on an enum:
    // `enum Foo { Bar, Baz }`
    // `this` -> `impl ThisFtl for Foo`.
    // `variants_this` -> ?
    
    // Maybe it creates a module `Foo` with `struct Bar; struct Baz;` and impls `ThisFtl` for them?
    // Or maybe it just generates `ThisFtl` for the enum but utilizing variants?
    
    // Let's look at `EsFluentKv` again.
    // `process_enum`: It generates `enum CountryLabelKvFtl`.
    // `keys_this`: generates `ThisFtl` for `CountryLabelKvFtl`.
    
    // I will strictly implement what is requested: `EsFluentThis` macro with `this`, `fields_this`, `variants_this` args.
    // Code generation:
    // 1. `this`: `impl ThisFtl for StructName` -> ret `struct_name_this`. (DONE in draft)
    // 2. `fields_this`: ??
    // 3. `variants_this`: ??
    
    // I will assume for now that `fields_this` and `variants_this` logic might need to traverse the AST.
    
    // For now, I'll output the basic implementation.
    
    let tokens = quote! {
        #this_ftl_impl
    };

    tokens.into()
}
